{"config":{"indexing":"full","lang":["de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Java Musterl\u00f6sung (jml) Java Musterl\u00f6sung (kurz jml ) ist ein Tool mit dem mehrere Projektversionen aus einer Musterl\u00f6sung generiert werden k\u00f6nnen. jml wurde urspr\u00fcnglich f\u00fcr Java-Projekte entwickelt, kann aber durch diverse Optionen auch f\u00fcr andere Projekte genutzt werden. Motivation Zur Differenzierung im Informatikunterricht erstelle ich gerne mehrere Projektversionen mit mehr oder weniger Hilfestellungen, um dem Leistungsstand der Sch\u00fclerinnen und Sch\u00fcler besser gerecht zu werden. Inklusive einer Musterl\u00f6sung k\u00f6nnen so schnell drei bis vier Projektversionen entstehen, die parallel weiterentwickelt werden m\u00fcssen. Befindet sich ein Fehler im Code, sollen die Aufgaben angepasst werden oder hat sich einfach ein Rechtschreibfehler in einen Kommentar eingeschlichen, m\u00fcssen alle Projektversionen angepasst werden. Dabei habe ich schnell mal eine Version vergessen oder einen neuen Fehler eingebaut. Vor einigen Jahren habe ich den Prozess mit jml vereinfacht. Das Skript generiert aus einer Basisversion, die mit Markierungen f\u00fcr Aufgaben und L\u00f6sungen versehen ist, die verschiedenen Projektversionen, die f\u00fcr den Unterricht n\u00f6tig sind. Anpassungen sind nur noch im Basisprojekt notwendig. Beispiele zur Verwendung finden sich in meinem Projekt-Repository und den dazugeh\u00f6rigen Projektversionen . Installation Die Installation wird wie gewohnt mit pip durchgef\u00fchrt: $ pip3 install jml Bei erfolgreicher Installation ist nun das jml Kommando verf\u00fcgbar. $ jml --version jml, version 0.3.6 jml ben\u00f6tigt Python 3.8 oder neuer. Manuelle Installation jml kann auch ohne pip einfach als Skriptdatei genutzt werden. Es werden keine externen Abh\u00e4ngigkeiten genutzt. Dazu die aktuelle Version der Datei jml.py <https://github.com/jneug/jml/blob/main/src/jml/jml.py> _ aus dem Repository kopieren und auf der Festplatte speichern. Das Skript kann dann mit Python 3 ausgef\u00fchrt werden: $ python3 jml.py --version jml, version 0.3.6 Benutzung jml ben\u00f6tigt im einfachsten Fall den Pfad des Basisprojektes und den Pfad des Ausgabeordners: $ jml pfad/zum/Basisprojekt --out pfad/zum/ausgabeordner Nach Ausf\u00fchrung befinden sich in pfad/zum/ausgabeordner die Musterl\u00f6sung und die Projektversionen. Die Inhalte und Anzahl an Versionen werden durch die Inhalte der Dateien im Basisprojekt bestimmt. Angenommen in Basisprojekt liegt eine Datei mit dem Namen Beispiel.java mit folgendem Inhalt: ``java class Beispiel { / aufg // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int aufg / //ml private int zahl; // ml public int add( int pAndereZahl ) { /*aufg* // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pAndereZahl\" zur\u00fcck. return 0; *aufg*/ //ml* return zahl + pAndereZahl; //*ml } } Dann erzeugt `jml` diese Ordnerstruktur in `pfad/zum/ausgabeordner` pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Basisprojekt/ \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 Basisprojekt_ML/ \u2514\u2500\u2500 Beispiel.java Inhalt von `Basisprojekt_ML/Beispiel.java`: ```java class Beispiel { private int zahl; public int add( int pAndereZahl ) { return zahl + pAndereZahl; } } Inhalt von Basisprojekt/Beispiel.java : class Beispiel { // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int public int add( int pAndereZahl ) { // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pAndereZahl\" zur\u00fcck. return 0; } } Mehrere Versionen Als Standard wird wie oben nur die Projektversion 0 erstellt. jml kann aber auch mehrere Projekte erstellen, wenn die Aufgaben-Markierungen mit einer entsprechenden Nummer versehen werden. Angenommen die Beispiel.java von oben sieht so aus: class Beispiel { /*aufg* // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int *aufg*/ //ml* private int zahl; //*ml public int add( int pAndereZahl ) { /*aufg* // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pSummand\" zur\u00fcck. return 0; *aufg*/ //ml* return zahl + pAndereZahl; //*ml } /*aufg* 2 public int sub( int pAndereZahl ) { // TODO: Gib die Differenz aus der Objektvariablen \"zahl\" und \"pSummand\" zur\u00fcck. return 0; } *aufg*/ } Dann werden statt der Version 0 die Projektversionen 1 und 2 erzeugt, da im zweiten Aufgaben-Marker eine konkrete Versionsnummer angegeben wurde: pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Basisprojekt_1/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Basisprojekt_2/ \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 Basisprojekt_ML/ \u2514\u2500\u2500 Beispiel.java Es ist auch m\u00f6glich eine Markierung f\u00fcr mehrere Projektversionen zu nutzen: /*aufg* >1 // Taucht nur in Projektversionen nach Version 1 auf. *aufg*/ /*aufg* !=2 // Taucht in allen Projektversionen au\u00dfer 2 auf. *aufg*/ /*aufg* <=2 // Taucht nur in Projektversionen 1 und 2 auf. *aufg*/ Seit Version 0.3.4 ist es m\u00f6glich, auch einem L\u00f6sungs-Tag eine Versionsnummer wie f\u00fcr Aufgaben zu geben. Dadurch wird der Inhalt zus\u00e4tzlich zur Musterl\u00f6sung auch in den spezifizierten Aufgabenversionen gesetzt: //ml* >1 // Taucht in der Musterl\u00f6sung und Versionen gr\u00f6\u00dfer 1 auf //*ml Optionen Die Funktion von jml ist durch eine Vielzahl von Optionen anpassbar. Die Optionen k\u00f6nnen als Kommandozeilen-Argumente \u00fcbergeben, oder in Konfigurationsdateien gespeichert werden. Eine \u00dcbersicht der verf\u00fcgbaren Kommandozeilen-Argumente ist mit -h abrufbar $ jml -h Alle Optionen (und noch eine Handvoll mehr) lassen sich auch in einer von mehreren Konfigurationsdateien festlegen. jml sucht dazu bei jedem Start nach .jml Dateien im Basisprojekt, im Wurzelverzeichnis ( --project-root ) und im Home-Ordner des angemeldeten Nutzers ( ~/.jml ). Die Konfigurationen werden dann in umgekehrter Reihenfolge geladen, die Einstellungen im Basisprojekt haben also die h\u00f6chste Priorit\u00e4t. Sie werden nur noch von Kommandozeilen-Argumente \u00fcberschrieben. F\u00fcr das Beispiel oben k\u00f6nnte der Aufbau so aussehen:: ~/ \u251c\u2500\u2500 .config/jml.toml \u251c\u2500\u2500 pfad/zur/wurzel/ \u2502 \u251c\u2500\u2500 jml.toml \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u251c\u2500\u2500 jml.toml \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 pfad/zum/ausgabeordner Inhalt von ~/.config/jml.toml : [tasks] open = \"/*<aufgabe>\" close = \"</aufgabe>*/\" [solutions] open = \"//<loesung>\" close = \"//</loesung>\" Inhalt von ~/pfad/zur/wurzel/jml.toml : name_format = {project}-{version} [sources] include = *.java,*.txt [solutions] suffix = \"Loesung\" [zip] create = true Inhalt von ~/pfad/zur/wurzel/Basisprojekt/jml.toml : name = Maeusekampf [sources] encoding = iso-8859-1 [tasks] open=/*aufgabe* close=*aufgabe*/ Der Aufruf von jml sieht dann so aus: $ jml --project-root \"~/pfad/zur/wurzel\" \"~/pfad/zur/wurzel/Basisprojekt\" --out \"pfad/zum/ausgabeordner\" jml l\u00e4dt nun zun\u00e4chst ~/.config/jml.toml und setzt die Start- und Endmarkierungen auf eine XML-Variante. Danach wird ~/pfad/zur/wurzel/jml.toml geladen, da dies per --project-root Argument als Wurzelverzeichnis gesetzt wurde. F\u00fcr diese Projektgruppe werden ZIP-Dateien der Projektversionen erzeugt, au\u00dferdem wird das Suffix f\u00fcr die Musterl\u00f6sung von ML auf Loesung ge\u00e4ndert. Das Format der Projektnamen wird angepasst ( _ durch - ersetzt) und es werden auch .txt Dateien nach den Aufgaben- und L\u00f6sungs-Markierungen durchsucht. Als drittes wird ~/pfad/zur/wurzel/Basisprojekt/jml.toml geladen. Hier werden speziell f\u00fcr dieses eine Projekt die Aufgaben-Marker erneut ver\u00e4ndert und die Datei-Codierung auf iso-8859-1 (statt utf-8 ) festgelegt. Schlie\u00dflich wird noch der Projektname auf Maeusekampf ge\u00e4ndert, anstatt den Ordnernamen Basisprojekt zu verwenden. Die Ausgabe sieht dann so aus (sofern die Aufgaben- und L\u00f6sungs-Markierungen in Beispiel.java angepasst wurden): ~/ \u251c\u2500\u2500 .jml \u251c\u2500\u2500 pfad/zur/wurzel/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Maeusekampf-Loesung/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-1/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-2/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-Loesung.zip \u251c\u2500\u2500 Maeusekampf-1.zip \u2514\u2500\u2500 Maeusekampf-2.zip","title":"Schnellstart"},{"location":"#java-musterlosung-jml","text":"Java Musterl\u00f6sung (kurz jml ) ist ein Tool mit dem mehrere Projektversionen aus einer Musterl\u00f6sung generiert werden k\u00f6nnen. jml wurde urspr\u00fcnglich f\u00fcr Java-Projekte entwickelt, kann aber durch diverse Optionen auch f\u00fcr andere Projekte genutzt werden.","title":"Java Musterl\u00f6sung (jml)"},{"location":"#motivation","text":"Zur Differenzierung im Informatikunterricht erstelle ich gerne mehrere Projektversionen mit mehr oder weniger Hilfestellungen, um dem Leistungsstand der Sch\u00fclerinnen und Sch\u00fcler besser gerecht zu werden. Inklusive einer Musterl\u00f6sung k\u00f6nnen so schnell drei bis vier Projektversionen entstehen, die parallel weiterentwickelt werden m\u00fcssen. Befindet sich ein Fehler im Code, sollen die Aufgaben angepasst werden oder hat sich einfach ein Rechtschreibfehler in einen Kommentar eingeschlichen, m\u00fcssen alle Projektversionen angepasst werden. Dabei habe ich schnell mal eine Version vergessen oder einen neuen Fehler eingebaut. Vor einigen Jahren habe ich den Prozess mit jml vereinfacht. Das Skript generiert aus einer Basisversion, die mit Markierungen f\u00fcr Aufgaben und L\u00f6sungen versehen ist, die verschiedenen Projektversionen, die f\u00fcr den Unterricht n\u00f6tig sind. Anpassungen sind nur noch im Basisprojekt notwendig. Beispiele zur Verwendung finden sich in meinem Projekt-Repository und den dazugeh\u00f6rigen Projektversionen .","title":"Motivation"},{"location":"#installation","text":"Die Installation wird wie gewohnt mit pip durchgef\u00fchrt: $ pip3 install jml Bei erfolgreicher Installation ist nun das jml Kommando verf\u00fcgbar. $ jml --version jml, version 0.3.6 jml ben\u00f6tigt Python 3.8 oder neuer.","title":"Installation"},{"location":"#manuelle-installation","text":"jml kann auch ohne pip einfach als Skriptdatei genutzt werden. Es werden keine externen Abh\u00e4ngigkeiten genutzt. Dazu die aktuelle Version der Datei jml.py <https://github.com/jneug/jml/blob/main/src/jml/jml.py> _ aus dem Repository kopieren und auf der Festplatte speichern. Das Skript kann dann mit Python 3 ausgef\u00fchrt werden: $ python3 jml.py --version jml, version 0.3.6","title":"Manuelle Installation"},{"location":"#benutzung","text":"jml ben\u00f6tigt im einfachsten Fall den Pfad des Basisprojektes und den Pfad des Ausgabeordners: $ jml pfad/zum/Basisprojekt --out pfad/zum/ausgabeordner Nach Ausf\u00fchrung befinden sich in pfad/zum/ausgabeordner die Musterl\u00f6sung und die Projektversionen. Die Inhalte und Anzahl an Versionen werden durch die Inhalte der Dateien im Basisprojekt bestimmt. Angenommen in Basisprojekt liegt eine Datei mit dem Namen Beispiel.java mit folgendem Inhalt: ``java class Beispiel { / aufg // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int aufg / //ml private int zahl; // ml public int add( int pAndereZahl ) { /*aufg* // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pAndereZahl\" zur\u00fcck. return 0; *aufg*/ //ml* return zahl + pAndereZahl; //*ml } } Dann erzeugt `jml` diese Ordnerstruktur in `pfad/zum/ausgabeordner` pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Basisprojekt/ \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 Basisprojekt_ML/ \u2514\u2500\u2500 Beispiel.java Inhalt von `Basisprojekt_ML/Beispiel.java`: ```java class Beispiel { private int zahl; public int add( int pAndereZahl ) { return zahl + pAndereZahl; } } Inhalt von Basisprojekt/Beispiel.java : class Beispiel { // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int public int add( int pAndereZahl ) { // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pAndereZahl\" zur\u00fcck. return 0; } }","title":"Benutzung"},{"location":"#mehrere-versionen","text":"Als Standard wird wie oben nur die Projektversion 0 erstellt. jml kann aber auch mehrere Projekte erstellen, wenn die Aufgaben-Markierungen mit einer entsprechenden Nummer versehen werden. Angenommen die Beispiel.java von oben sieht so aus: class Beispiel { /*aufg* // TODO: Erstelle eine Objektvariable \"zahl\" vom Typ int *aufg*/ //ml* private int zahl; //*ml public int add( int pAndereZahl ) { /*aufg* // TODO: Gib die Summe aus der Objektvariablen \"zahl\" und \"pSummand\" zur\u00fcck. return 0; *aufg*/ //ml* return zahl + pAndereZahl; //*ml } /*aufg* 2 public int sub( int pAndereZahl ) { // TODO: Gib die Differenz aus der Objektvariablen \"zahl\" und \"pSummand\" zur\u00fcck. return 0; } *aufg*/ } Dann werden statt der Version 0 die Projektversionen 1 und 2 erzeugt, da im zweiten Aufgaben-Marker eine konkrete Versionsnummer angegeben wurde: pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Basisprojekt_1/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Basisprojekt_2/ \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 Basisprojekt_ML/ \u2514\u2500\u2500 Beispiel.java Es ist auch m\u00f6glich eine Markierung f\u00fcr mehrere Projektversionen zu nutzen: /*aufg* >1 // Taucht nur in Projektversionen nach Version 1 auf. *aufg*/ /*aufg* !=2 // Taucht in allen Projektversionen au\u00dfer 2 auf. *aufg*/ /*aufg* <=2 // Taucht nur in Projektversionen 1 und 2 auf. *aufg*/ Seit Version 0.3.4 ist es m\u00f6glich, auch einem L\u00f6sungs-Tag eine Versionsnummer wie f\u00fcr Aufgaben zu geben. Dadurch wird der Inhalt zus\u00e4tzlich zur Musterl\u00f6sung auch in den spezifizierten Aufgabenversionen gesetzt: //ml* >1 // Taucht in der Musterl\u00f6sung und Versionen gr\u00f6\u00dfer 1 auf //*ml","title":"Mehrere Versionen"},{"location":"#optionen","text":"Die Funktion von jml ist durch eine Vielzahl von Optionen anpassbar. Die Optionen k\u00f6nnen als Kommandozeilen-Argumente \u00fcbergeben, oder in Konfigurationsdateien gespeichert werden. Eine \u00dcbersicht der verf\u00fcgbaren Kommandozeilen-Argumente ist mit -h abrufbar $ jml -h Alle Optionen (und noch eine Handvoll mehr) lassen sich auch in einer von mehreren Konfigurationsdateien festlegen. jml sucht dazu bei jedem Start nach .jml Dateien im Basisprojekt, im Wurzelverzeichnis ( --project-root ) und im Home-Ordner des angemeldeten Nutzers ( ~/.jml ). Die Konfigurationen werden dann in umgekehrter Reihenfolge geladen, die Einstellungen im Basisprojekt haben also die h\u00f6chste Priorit\u00e4t. Sie werden nur noch von Kommandozeilen-Argumente \u00fcberschrieben. F\u00fcr das Beispiel oben k\u00f6nnte der Aufbau so aussehen:: ~/ \u251c\u2500\u2500 .config/jml.toml \u251c\u2500\u2500 pfad/zur/wurzel/ \u2502 \u251c\u2500\u2500 jml.toml \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u251c\u2500\u2500 jml.toml \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 pfad/zum/ausgabeordner Inhalt von ~/.config/jml.toml : [tasks] open = \"/*<aufgabe>\" close = \"</aufgabe>*/\" [solutions] open = \"//<loesung>\" close = \"//</loesung>\" Inhalt von ~/pfad/zur/wurzel/jml.toml : name_format = {project}-{version} [sources] include = *.java,*.txt [solutions] suffix = \"Loesung\" [zip] create = true Inhalt von ~/pfad/zur/wurzel/Basisprojekt/jml.toml : name = Maeusekampf [sources] encoding = iso-8859-1 [tasks] open=/*aufgabe* close=*aufgabe*/ Der Aufruf von jml sieht dann so aus: $ jml --project-root \"~/pfad/zur/wurzel\" \"~/pfad/zur/wurzel/Basisprojekt\" --out \"pfad/zum/ausgabeordner\" jml l\u00e4dt nun zun\u00e4chst ~/.config/jml.toml und setzt die Start- und Endmarkierungen auf eine XML-Variante. Danach wird ~/pfad/zur/wurzel/jml.toml geladen, da dies per --project-root Argument als Wurzelverzeichnis gesetzt wurde. F\u00fcr diese Projektgruppe werden ZIP-Dateien der Projektversionen erzeugt, au\u00dferdem wird das Suffix f\u00fcr die Musterl\u00f6sung von ML auf Loesung ge\u00e4ndert. Das Format der Projektnamen wird angepasst ( _ durch - ersetzt) und es werden auch .txt Dateien nach den Aufgaben- und L\u00f6sungs-Markierungen durchsucht. Als drittes wird ~/pfad/zur/wurzel/Basisprojekt/jml.toml geladen. Hier werden speziell f\u00fcr dieses eine Projekt die Aufgaben-Marker erneut ver\u00e4ndert und die Datei-Codierung auf iso-8859-1 (statt utf-8 ) festgelegt. Schlie\u00dflich wird noch der Projektname auf Maeusekampf ge\u00e4ndert, anstatt den Ordnernamen Basisprojekt zu verwenden. Die Ausgabe sieht dann so aus (sofern die Aufgaben- und L\u00f6sungs-Markierungen in Beispiel.java angepasst wurden): ~/ \u251c\u2500\u2500 .jml \u251c\u2500\u2500 pfad/zur/wurzel/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 Beispiel.java \u2514\u2500\u2500 pfad/zum/ausgabeordner/ \u251c\u2500\u2500 Maeusekampf-Loesung/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-1/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-2/ \u2502 \u2514\u2500\u2500 Beispiel.java \u251c\u2500\u2500 Maeusekampf-Loesung.zip \u251c\u2500\u2500 Maeusekampf-1.zip \u2514\u2500\u2500 Maeusekampf-2.zip","title":"Optionen"},{"location":"examples/","text":"Anwendungsbeispiele Das folgende Beispiel kopiert die .class Dateien mit in die Projektversionen und ignoriert daf\u00fcr einige ausgew\u00e4hlte .java Quelltexte. Dies kann sinnvoll sein, wenn das Projekt einige vordefinierte Klassen enth\u00e4lt (zum Beispiel eine fertige GUI), die von den Sch\u00fcler:innen aber nicht bearbeitet werden sollen. ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2514\u2500\u2500 .jml \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/jml.toml : output_dir = \"~/ausgabe/ordner\" name_format = \"{project}-v{version}\" [tasks] open = \"/*<aufg>\" close = \"</aufg>*/\" [solutions] open = \"//<ml>\" close = \"//</ml>\" [zip] only_zip = true [[files]] name = \".gitignore\" source = \"~/wurzel/verzeichnis/files/.gitignore\" [[files]] name = \"package.bluej\" source = \"~/wurzel/verzeichnis/files/package.bluej\" Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : project_root = \"~/wurzel/verzeichnis\" [sources] exclude = [ \"MyMailGUI.java\", \"MyMailSettingsGUI.java\" \"-*.class\" ] Andere Sprachen Mit diesen Einstellungen kann jml zum Beispiel auch f\u00fcr ein HTML-Projekt genutzt werden: ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 index.html \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : [tasks] open = \"<!--aufg\" close = \"/aufg-->\" [solutions] open = \"<!--ml-->\" close = \"<!--/ml-->\" [sources] include = [\"*.html\", \"*.htm\", \"-*.java\"] Sprachen ohne Blockkommentare Einige Programmiersprachen (wie Python oder TeX) besitzen keine Block-, sondern nur Zeilenkommentare. F\u00fcr diese F\u00e4lle gibt es die Optionen task.line.prefix und solutions.line.prefix , mit denen eine Zeichenkette festgelegt werden kann, die am Anfang jeder Zeile entfernt wird. ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 beispiel.py \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : [tasks] open = \"# aufgb:\" close = \"# aufg\" line.prefix = \"#\" [solutions] open = \"# ml:\" close = \"# ml\" [sources] include = [\"*.py\"] Markdown Beispiel Markdown-Dokumente besitzen in der Original-Syntax keine Kommentare, daher werden die Markierungen im Basisprojekt angezeigt. Auch die Aufgabenstellungen lassen sich dann nicht verstecken. Ansonsten funktioniert jml ohne weiteres auch mit Markdown-Dateien. Wird die Markdown-Datei in HTML konvertiert, dann wird nach Konverter werden aber auch HTML-Kommentare interpretiert und in der Ausgabe versteckt. Daher k\u00f6nnte dieselbe Konfiguration wie oben verwendet werden. Das Beispiel zeigt eine Konfiguration, um aus einer Markdown-Datei zwei Arbeitsbl\u00e4tter mit Rechenaufgaben zu generieren. [tasks] open = \"<!--aufg\" close = \"/aufg-->\" [solutions] open = \"<!--ml-->\" close = \"<!--/ml-->\" [sources] include = [\"*.md\",\"*.mdown\",\"*.markdown\"] # Kopfrechnen ## Aufgabe 1 <!--aufg 1 1. \\[ 5+8\\cdot 12 = \\] /aufg--> <!--aufg 2 1. /aufg--> <!--ml--> ### Variante 1 1. \\[ 5+8\\cdot 12 = 101 \\] ### Variante 2 <!--/ml--> Weitere Aufgaben ... TeX Beispiel F\u00fcr TeX wird die Python-Konfiguration oben angepasst, so dass % als Kommentarzeichen interpretiert wird: [tasks] open = \"%\\\\begin{aufg}\" close = \"%\\\\end{aufg}\" line.prefix = \"%\" [solutions] open = \"%\\\\begin{ml}\" close = \"%\\\\end{ml}\" [sources] include = [\"*.tex\"] Eine andere Herangehensweise w\u00e4re es, im Kopf der TeX-Datei Umgebungen zu definieren, die den Inhalt beim Satz der Basisversion verstecken. Dieses Vorgehen kann z.B. f\u00fcr den Satz von Klassenarbeiten mit mehreren Varianten hilfreich sein. ```toml [tasks] open = \"\\\\begin{jmlaufgabe}\" close = \"\\\\end{jmlaufgabe}\" [solutions] open = \\begin{jml} close = \\end{jml} [sources] include = [\"*.tex\"] Erweiterte Ersetzungen task.line.prefix und solution.line.prefix k\u00f6nnen auch zusammen mit den Optionen task.line.replace und solutions.line.replace genutzt werden, um das Prefix nicht einfach zu entfernen, sondern um eine eigene Ersetzung zu definieren. Dabei lassen sich auch Gruppen aus prefix in replace mit \\1 , \\2 , usw. referenzieren. Dieser Modus kann hilfreich sein, um komplexere Kommentar-Syntax oder ganz andere Einsatzzwecke zu erm\u00f6glichen. Diese jml.toml Datei w\u00fcrde die Aufgaben-Markierungen auf ein HTML-Format \u00e4ndern und innerhalb des Aufgaben-Blocks in jeder Zeile die Kommentare entfernen, die ein TODO: enthalten: [tasks] open = \"<!--aufg start-->\" close = \"<!--aufg end-->\" line.prefix = \"<!-- TODO: (.+) -->\" line.replace = \"\\\\1\" Zum Beispiel w\u00fcrde aus ```html <!--aufg start--> <!-- F\u00fcge hier deine L\u00f6sung ein --> <!-- TODO: <div></div> --> <!--aufg end--> dann die Ausgabe <!-- F\u00fcge hier deine L\u00f6sung ein --> <div></div> Wie man sieht, bleibt der Kommentar ohne TODO: erhalten.","title":"Examples"},{"location":"examples/#anwendungsbeispiele","text":"Das folgende Beispiel kopiert die .class Dateien mit in die Projektversionen und ignoriert daf\u00fcr einige ausgew\u00e4hlte .java Quelltexte. Dies kann sinnvoll sein, wenn das Projekt einige vordefinierte Klassen enth\u00e4lt (zum Beispiel eine fertige GUI), die von den Sch\u00fcler:innen aber nicht bearbeitet werden sollen. ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 .jml \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2514\u2500\u2500 .jml \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/jml.toml : output_dir = \"~/ausgabe/ordner\" name_format = \"{project}-v{version}\" [tasks] open = \"/*<aufg>\" close = \"</aufg>*/\" [solutions] open = \"//<ml>\" close = \"//</ml>\" [zip] only_zip = true [[files]] name = \".gitignore\" source = \"~/wurzel/verzeichnis/files/.gitignore\" [[files]] name = \"package.bluej\" source = \"~/wurzel/verzeichnis/files/package.bluej\" Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : project_root = \"~/wurzel/verzeichnis\" [sources] exclude = [ \"MyMailGUI.java\", \"MyMailSettingsGUI.java\" \"-*.class\" ]","title":"Anwendungsbeispiele"},{"location":"examples/#andere-sprachen","text":"Mit diesen Einstellungen kann jml zum Beispiel auch f\u00fcr ein HTML-Projekt genutzt werden: ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 index.html \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : [tasks] open = \"<!--aufg\" close = \"/aufg-->\" [solutions] open = \"<!--ml-->\" close = \"<!--/ml-->\" [sources] include = [\"*.html\", \"*.htm\", \"-*.java\"]","title":"Andere Sprachen"},{"location":"examples/#sprachen-ohne-blockkommentare","text":"Einige Programmiersprachen (wie Python oder TeX) besitzen keine Block-, sondern nur Zeilenkommentare. F\u00fcr diese F\u00e4lle gibt es die Optionen task.line.prefix und solutions.line.prefix , mit denen eine Zeichenkette festgelegt werden kann, die am Anfang jeder Zeile entfernt wird. ~/ \u251c\u2500\u2500 wurzel/verzeichnis/ \u2502 \u251c\u2500\u2500 files/ \u2502 \u2502 \u251c\u2500\u2500 .gitignore \u2502 \u2502 \u2514\u2500\u2500 package.bluej \u2502 \u2514\u2500\u2500 Basisprojekt/ \u2502 \u2502 \u251c\u2500\u2500 .jml \u2502 \u2514\u2500\u2500 beispiel.py \u2514\u2500\u2500 ausgabe/ordner Inhalt von ~/wurzel/verzeichnis/Basisprojekt/jml.toml : [tasks] open = \"# aufgb:\" close = \"# aufg\" line.prefix = \"#\" [solutions] open = \"# ml:\" close = \"# ml\" [sources] include = [\"*.py\"]","title":"Sprachen ohne Blockkommentare"},{"location":"examples/#markdown-beispiel","text":"Markdown-Dokumente besitzen in der Original-Syntax keine Kommentare, daher werden die Markierungen im Basisprojekt angezeigt. Auch die Aufgabenstellungen lassen sich dann nicht verstecken. Ansonsten funktioniert jml ohne weiteres auch mit Markdown-Dateien. Wird die Markdown-Datei in HTML konvertiert, dann wird nach Konverter werden aber auch HTML-Kommentare interpretiert und in der Ausgabe versteckt. Daher k\u00f6nnte dieselbe Konfiguration wie oben verwendet werden. Das Beispiel zeigt eine Konfiguration, um aus einer Markdown-Datei zwei Arbeitsbl\u00e4tter mit Rechenaufgaben zu generieren. [tasks] open = \"<!--aufg\" close = \"/aufg-->\" [solutions] open = \"<!--ml-->\" close = \"<!--/ml-->\" [sources] include = [\"*.md\",\"*.mdown\",\"*.markdown\"] # Kopfrechnen ## Aufgabe 1 <!--aufg 1 1. \\[ 5+8\\cdot 12 = \\] /aufg--> <!--aufg 2 1. /aufg--> <!--ml--> ### Variante 1 1. \\[ 5+8\\cdot 12 = 101 \\] ### Variante 2 <!--/ml--> Weitere Aufgaben ...","title":"Markdown Beispiel"},{"location":"examples/#tex-beispiel","text":"F\u00fcr TeX wird die Python-Konfiguration oben angepasst, so dass % als Kommentarzeichen interpretiert wird: [tasks] open = \"%\\\\begin{aufg}\" close = \"%\\\\end{aufg}\" line.prefix = \"%\" [solutions] open = \"%\\\\begin{ml}\" close = \"%\\\\end{ml}\" [sources] include = [\"*.tex\"] Eine andere Herangehensweise w\u00e4re es, im Kopf der TeX-Datei Umgebungen zu definieren, die den Inhalt beim Satz der Basisversion verstecken. Dieses Vorgehen kann z.B. f\u00fcr den Satz von Klassenarbeiten mit mehreren Varianten hilfreich sein. ```toml [tasks] open = \"\\\\begin{jmlaufgabe}\" close = \"\\\\end{jmlaufgabe}\" [solutions] open = \\begin{jml} close = \\end{jml} [sources] include = [\"*.tex\"]","title":"TeX Beispiel"},{"location":"examples/#erweiterte-ersetzungen","text":"task.line.prefix und solution.line.prefix k\u00f6nnen auch zusammen mit den Optionen task.line.replace und solutions.line.replace genutzt werden, um das Prefix nicht einfach zu entfernen, sondern um eine eigene Ersetzung zu definieren. Dabei lassen sich auch Gruppen aus prefix in replace mit \\1 , \\2 , usw. referenzieren. Dieser Modus kann hilfreich sein, um komplexere Kommentar-Syntax oder ganz andere Einsatzzwecke zu erm\u00f6glichen. Diese jml.toml Datei w\u00fcrde die Aufgaben-Markierungen auf ein HTML-Format \u00e4ndern und innerhalb des Aufgaben-Blocks in jeder Zeile die Kommentare entfernen, die ein TODO: enthalten: [tasks] open = \"<!--aufg start-->\" close = \"<!--aufg end-->\" line.prefix = \"<!-- TODO: (.+) -->\" line.replace = \"\\\\1\" Zum Beispiel w\u00fcrde aus ```html <!--aufg start--> <!-- F\u00fcge hier deine L\u00f6sung ein --> <!-- TODO: <div></div> --> <!--aufg end--> dann die Ausgabe <!-- F\u00fcge hier deine L\u00f6sung ein --> <div></div> Wie man sieht, bleibt der Kommentar ohne TODO: erhalten.","title":"Erweiterte Ersetzungen"},{"location":"ides/","text":"Integration in IDEs In Entwicklungsumgebungen wie Eclipse , IntelliJ und vscode _ l\u00e4sst sich jml relativ einfach als externes Tool einbinden. Die IDEs erlauben in der Regel die Verwendung von Platzhaltervariablen, mit denen der Aufruf von jml angepasst werden kann. .. _Eclipse: https://www.eclipse.org .. _IntelliJ: https://www.jetbrains.com/idea/ .. _vscode: https://vscodium.com","title":"Integration in IDEs"},{"location":"ides/#integration-in-ides","text":"In Entwicklungsumgebungen wie Eclipse , IntelliJ und vscode _ l\u00e4sst sich jml relativ einfach als externes Tool einbinden. Die IDEs erlauben in der Regel die Verwendung von Platzhaltervariablen, mit denen der Aufruf von jml angepasst werden kann. .. _Eclipse: https://www.eclipse.org .. _IntelliJ: https://www.jetbrains.com/idea/ .. _vscode: https://vscodium.com","title":"Integration in IDEs"}]}